<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Document</title>
        <style>
        *{
            padding: 0;
            margin: 0;
        }
        div{
            position: absolute;
            left:calc(50% - 100px);
            top:calc(50% - 100px);
            width: 200px;
            height: 200px;

            /*background-image通常体现的是装饰*/
            /*background-image既可以放背景图片也可以放渐变颜色linear-gradient()*/
            /*background-image: linear-gradient(to right,#0f0 10px,#ff0 30px,#f0f 150px);/*第一个参数改变的是渐变的方向
            每一个颜色后面都可以添加一个像素值，表示的是到当前的值结束是这部分的颜色*/
            background-image: radial-gradient(circle closest-side at 100px 0px,#0f0 ,green ,#0ff );/*第一个参数是
            圆心的位置，放射半径(必须放到形状和at之间)：closest-side,closest-corner,farthest-side,farthest-corner*/

            /*可以引入多张图片，代码如下*/
            /* background-image: url(),url(); */
            /* background-size: 100px 200px,100px 200px;
            background-repeat: no-repeat;
            background-position: 0 0,100px 0; */

            /* background-origin: ;图片打哪起始的：border-box padding-content content-box */
            /*background-origin: padding-box;/**默认值是padding-box*/
            /*background-repeat: no-repeat;
            background-position: 20px  20px;/*origin从哪开始的position的就是相对谁的*/
            
            /* background-clip: 默认值是border-box;打哪开始结束:border-box padding-box content-box text */
           
            /* background-attachment: ; */
            
            /* background-size: ; cover->让一张填充到内容区，不改变图片的比列，可能存在
                超出的风险，一条边对齐，另一条边一定>=这条边；contain也是不改变图片的比例，完整的放在内容区，会存在repeat的风险，
                一条边对齐，另一条边一定<=这条边。*/
            

            /* background-repeat: ;round-->平铺(不够就拉伸，够就压缩添加) space-->不会改变图片的大小，不够就利用空白填充，够就添加图片 */
            /* background-repeat: round space; 只有当值为round和space的时候才能填两个值，剩下的都只能填一个值*/
        }

        /* .demo{ */
            /* background-clip: text;用文字截取背景图片 */
            /* height: 100px;
            line-height: 100px;
            font-size: 80px;
            font-weight: bold;
            width: 400px;
            position: absolute;
            left:calc(50% - 200px);
            top: 100px;
            background-image:url();
            -webkit-background-clip: text;
            background-clip: text; */
            /*-webkit-text-fill-color就是配合background-clip使用的*/
            /* -webkit-text-fill-color: transparent; */
        /* } */

        .box{
            width: 500px;
            height: 700px;
            border: 1px solid red;
            overflow: scroll;
            background-image: url('mine.png');
            background-size: 300px 400px;
            background-repeat: no-repeat;
            background-position: 100px 100px;
            /*默认的scroll相对于容器进行定位  fixed相对于屏幕的视口进行定位，永远都不动，但是不能在内容区之外显示*/
            background-attachment: local;/*背景图片相对于内容区定位*/
        }
    </style>
    </head>
    <body>
        <div></div>
        <!-- <div class="demo">成哥很帅</div> -->

        <!-- <div class="box">选择：
            1. 组成BOM的对象中不包含（C）
            A. History B. Screen C. Document D. Location

            2. Location上的哪个属性更改不会刷新页面(D)
            A. href B. search C. host D. hash

            3. 以下哪个方法没有对数组进行遍历操作(D)
            A. Reduce B. Map C. Sort D. Pop

            4. userAgent属性不包含下列哪种信息(B)
            A．浏览器渲染引擎 B.设备分辨率 C. 操作系统 D.浏览器版本

            5. 在js中获取div标签对应的Dom对象oDiv, 执行oDiv.class = ‘duyi’，div标签上或出现（A）
            A．class = ‘duyi’ B. className =’duyi’ C.空 D. class=’’

            填空：
            1. DOM中文名称为文档对象模型，是js操作文档的中介，BOM中文名称为浏览器对象模型，是js操作__浏览器__中介。
            2. History可以通过_go____方法进行页面回退2步操作。
            3. Label标签通过_for____属性和其他标签进行关联。
            4. 数组ForEach和普通的for循环哪个遍历效率更高__forEach__。
            5.
            模拟重力场的课中是通过_小块距离顶部的高度=document.clientHeight-小块的高度___公式判断该物体正好运动到浏览器底部。
            大题：
            1.定义数组：var arr = [{name: ‘cst’, age: ‘18’}, {name: ‘jc’, age: ‘20’},
            {name: ‘dxm’, age: ‘50’} , {name: ‘dcg’, age:
            ‘30’}]。利用filter和map对数组进行操作：留下name中包含c的，并且让他们的年龄都加上自身大小。
            var arr=[
            {name:"cst",age:"18"},
            {name:"jc",age:"20"},
            {name:"dxm",age:"50"},
            {name:"dcg",age:"30"}
            ];
            var newArr=arr.filter(function(ele,index,self){
            if(ele.name.indexOf('c')!=-1){
            return true;
            }
            });
            var finalArr=newArr.map(function(ele,index,self){
            ele.age=(parseInt(ele.age)+10)+"";
            return ele;
            });
            console.log(finalArr);
            2.用你能想到较好的，且通用方式把浏览器输入框上的网址（如：https://www.baidu.com/s?ie=utf-8&f=8）按协议：https
            主机：www.baidu.com 路径：/s 参数：ie=utf-8&f=8划分并创建对象。
            此对象属性和属性值形式如右：{protocol: ‘https’, host：‘www.baidu.com’, path: ‘/s’,
            search: {ie:’utf-8’,f:’8’}};
            function parseCookie (str) {
            var obj = {}, arr = null;
            arr = str.split('; ');
            arr.myReduce(function (prev, icur, index, self) {
            var icurArr = icur.split('=');
            prev[icurArr[0]] = icurArr[1];
            return prev;
            }, obj);
            return obj;
            }
            3.
            实现一个getDom(str)函数，可以根据参数（str形式如：‘#id’、’.Class’、‘tag’）的不同选择对应选择不同的dom。
            注：1.‘#id’此参数为根据id名称选择dom，.Class此参数为根据类名选择dom，‘tag’此参数为根据标签名称获取dom。2.不能使用原生的getElementsByClassName方法
            function getDom(str){
            if(str.indexOf(id)!=-1){
            return typeof(id) === "string"?document.getElementById(id):id;
            }else{
            var domArr = document.getElementsByTagName("*");
            var arr = [];
            var index = 0;
            for( var i = 0; i domArr.length; i+=i){
            if(domArr.className == str) {
            arr[index] = domArr[ i ];
            index++
            }
            }
            return arr;
            }
            }

            4. 请尝试写出缓冲运动的效果。
          5.
            32. oBtn.onclick=function(){
            33. starMove(oDiv,300);
            34. }
            35. function startMove(dom,target){
            36. clearInterval(timer);
            37. var iSpeed=0;
            38. timer=setInterval(function(){
            39. iSpeed=(target-dom.offsetLeft)/7;
            40. iSpeed=iSpeed>0?Math.ceil(iSpeed):Math.floor(iSpeed);
            41. if(dom.offsetLeft===300){
            42. clearInterval(timer);
            43. }else{
            44. dom.style.left=dom.offsetLeft+iSpeed+"px";
            45. }
            46. },30);
            47. }
            48.

            49. 请用伪代码（用中文分步描述逻辑）写出轮播图的制作思路。
            假如要轮播的是五张图片，那么真正需要的是六张图片，即第六章与第一张相同，将图片装入一个大的ul里面，让ul整体运动。
            默认情况下ul是向左运动，即在运动函数中传入的对象中的left值始终是的,每当ul向左运动的距离为-index*图片的宽度时，运动停止。当显示的是第五张图片时，让ul接着运动，当第六张显示出来时，让ul.offsetLeft=0，且index=0。
            轮播图通过左右按钮能够向左或者向右运动，因此要注意按钮的点击方向，向左按钮left>0，当处在第一张照片时，点击向左按钮，此时的index=5,ul.offsetLeft=5*图片的宽度,然后index--，显示第五张图片。点击向右按钮和默认向左运动的实现效果是一样的。
            无论是按钮点击还是默认运动，每一个运动都是独立的，不能互相打扰，因此每一种情况在运动的时候必须加上一个锁，只有当前的运动结束之后，lock=true，才能在开始下一次运动。
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>
        </div> -->
    </body>
</html>