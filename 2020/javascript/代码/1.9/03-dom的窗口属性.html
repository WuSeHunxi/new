<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        div{
            width: 100px;
            height: 100px;
            background-color: yellow;
        }
    </style>
</head>
<body>
    <div></div>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <script>
        /***
            窗口属性
                查看滚动条滚动的距离:
                    window.pageOffsetX/pageOffsetY(不兼容)
                    IE8及其以下的查看滚动条的方法:
                        document.body.scrollLeft/Top
                        document.documentElement.scrollLeft/Top
        */

        //封装一个方法,实时得到滚动条的距离
        function getScrollOffset(){
            if(window.pageXOffset){
                return {
                    x:window.pageXOffset,
                    y:window.pageYOffset
                }
            }else{
                return {
                    x:document.body.scrollLeft+document.documentElement.scrollLeft,
                    y:document.body.scrollTop+document.documentElement.scrollTop
                }
            }
        }



        /***
         * 
         * 查看可视区窗口的尺寸:能够编写的文档的部分(不包含导航栏和地址栏)
         *      window.innerWidth/innerHeight
         *          window.innerHeight
                    578
                    window.innerWidth
                    725
         *      IE8及其以下查看可视区窗口尺寸的方法:
         *          document.documentElement.clientHeight/clientWidth---->标准模式
         *          document.body.clientWidth/clientHeight---->怪异模式
         * 
         * 
         * 浏览器的怪异模式(混杂模式):向后兼容(为了兼容之前的语法)
         *      如何判断浏览器的模式?
         *          document.compatMode--->"CSS1Compat"  BackCompat(向后兼容)
         * 
        */

        //封装方法
        function getViewportOffset(){
            if(window.innerWidth){
                return {
                    w:window.innerWidth,
                    h:window.innerHeight
                }
            }else{
                if(document.compatMode==="BackCompat"){
                    return  {
                        w:document.body.clientWidth,
                        h:document.body.clientHeight
                    }
                }else{
                    return {
                        w:document.documentElement.clientWidth,
                        h:document.documentElement.clientHeight
                    }
                }
            }
        }


        var div=document.getElementsByTagName("div")[0];

        /**
         * 求得元素的尺寸-->getBoundingClientRect()
         *      会得到一个对象包含:宽 高 left top等属性,但是在IE浏览器中得到的这个对象没有宽高属性
         * 
         * 查看元素尺寸:
         *     xxx.offsetWidth/offsetHeight
         *     
         * offsetLeft---->对于无定位的父级元素,返回相对文档的坐标
         *                对于有定位的父级元素,返回相对与最近的有定位的父级的坐标
         * 
         * window上的三个方法
         *     scroll(x,y)--->让滚动条滚动到(x,y)的位置
         *     scrollTo(x,y)--->让滚动条滚动到(x,y)的位置
         *     scrollBy(x,y)--->(累加)能够实现快速阅读的功能
         * **/

        

        /**
         * DOM操作css
         *     改变float的时候需要在前面加上css---->cssFloat
         *          div.style.cssFloat="right"
         *     
         *     window.getComputedStyle(xxx,null)--->获取当前这个元素所展示的一切css显示值,和权重有关
         *          并且返回的样式都是绝对值,没有相对单位,但是有兼容性问题,在IE8及其以下使用xxx.currentStyle,
         *          但是这个方法获取的值不会发生转变,即:你设置的是啥得到的就是啥,而且别的浏览器用不了
         *        window.getComputedStyle(xxx,xxx)--->第二个参数可以获取伪元素
         *             window.getComputedStyle(谁的伪元素,after/before)
         * 
         *     xxx.style.xxx---->获取的是行间的样式
         *          
         * 
        */

        //封装getStyle()方法--->获取元素的css属性
        function getStyle(elem,prop){
            if(window.getComputedStyle){
                return window.getComputedStyle(elem,null)[prop];
            }else{
                return elem.currentStyle[prop];
            }
        }

        //left和top的默认值是auto

    </script>
</body>
</html>